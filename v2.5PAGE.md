## 倒序排列 及分页问题

### 场景1 ：分页


### 场景2： 单纯的正逆排序查找


### 场景3： 扩展表的排序
扩展表的排序 因为是非切分字段， 已经定位到某个用户了所以 直接排序 不存在对扩展索引的在排序问题？

例如 对某个用户的道具排序 某个用户的道具存在x表 ，该用户的所有道具，活着数据都存在这个表里，所以直接排序就可以了


问题2： 如果多个用户的排序呢？  对10个用户用户 分数进行排名怎么做？

做法：这个排名 10个用户信息中 ，然后在程序层进行排序。

问题2.1: 如果要在扩展表中进行排序怎么做呢？

#### 需求是什么？
扩展表中因为和切分键是 多对1的关系 所以 基于主键的逆排序是不存在的，
或者扩展表的主键id 是额外的切分主键 这种情况下 切分主键表的关联 如果基于用户查找 ， 怎么定位到某一个具体的表呢？

问题2.1.1： 基于两个主键进行切分  uuid 为1  和 pid 双重切分可行吗？
回答2.1.1: 语句pid的话 那需要传过来pid 才可以定位表。 而基于uuid的话 穿过来uuid 可以找到所有该用户的道具。
需求不明确暂时不考虑






做法通常： 从 select * form user where uuid in(1,2,3,4,5) order by score desc
这个子句怎么操作？？？
答案： 目前返回匹配的数据但是没有排序！
#### 这个子句 目前会扫描全表 然后混合  排序是没有的




### 问题3： 区间划分的排序结构！

#### 情况 3.1:（是什么） 单纯的 offset 2000 limit 3  或者 limit 2000 3
#### 情况 3.2: (是什么)   limit 2000 15 order by tipic desc
##### 情况 3.2.1: 引发问题： 入口表， 区间索引主表  重要概念
· 就是从应从层开始 查询够早从上往下的 检索过程， 在低级表不需要单独的进行 。


### 情况 3.3: where 子句 where statu=0  limit 2000 15 order by uuid desc
#### 3.3.1 这种情况是最常见的 扩展情况
##### 3.3.1.1 status =0 and delete !=1 limit 2150 13 order by datatime desc
 说明这种情况后边的 datatime 是不支持的，
支持的应该是 **status =0 and delete !=1 limit 2150 13 order by uuid| topic desc**
等 **区间划分的字段 这些区间划分的字段和时间是有一定关联的， 数值越大 那么也就是日期最新的**
##### 3.3.1.2 针对上述问题的的解决方案

1. limit 子句部分 必须
2.  where 子句部分必须
3. 获取切分字段 用于排序
3. 排序部分 可以生路 用page 用page特定标记替换（传递asc 或desc 就可以了 然后拼合查询语句）

4. 数据库信息必须
5. 根据偏移量获取最小表 索引？
    生成数额查询根据sql 拿到该表总的符合条件的行数
6. 根据 条数 获取最大 索引值
        2150+12
    生成数额查询语句 sql 拿到该表的符合条件的行数
    如果 两个索引都在一个表区间 就查询

* 情况1 都分布在一个表里边 总条数足够
* 情况2 分布在两个表里  最新的表里边条数不够 需要老表不足
* 情况2.1 偏移计算是在第二个表 ， 第二个表一共有6条数据， 但是删除掉了 1条，缺少9条
那就自动吧所以向前减一 并保证不小于最小索引 进行统计查询。如果向签一个表的数值够 就吧偏移减低成减少后的索引
，然后查询。
 问题： 如果取后 行记录又删除，还是不够 这样拿回来的数据还是少 怎么办呢？
 SELECT * FROM table LIMIT 5;     //检索前 5 个记录行  跨表采用这种语法 需要偏移两码？

 问题： 在单表情况下 需要切分吗
· LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)： 为了与 PostgreSQL 兼容，MySQL 也支持句法： LIMIT # OFFSET #。
·
解释： 快表情况下 是否需要偏移量呢？ 例如

每表2000条
正常情况

取 offsert 1995 - 15
min 1995   idx = 0   2000-1995= 5 条     idx 0 5条  逆序
max 1995+15 = 2010  2010-2000=10  idx = 1  idx 1 取10条 正序


有删除的情况
1995  中间删除了 1条  总共变成了 1999条
怎么处理


总共统计到是  条的话
idx 0 1900 删除了100条
idx 1 1700 删除了 300条
idx 2 1001  删除了20条

怎么计算

早起查询数
select * from topic_0 order by topic_id desc limit 3;
扩展查询数
 select * from topic_0 order by topic_id asc limit 5;

这里的问题在哪里 在与 被删除的数据影响
有以下几个数值
1。 offfset  行数  1995 15
2： 每个表的最大 行数 2000
3： 实际的行数  1900  被删除了 100条

所以当取 1995的时候

最小的范围就是 1995 /2000   idx = 0
max 1995+15 = 2010  idx =1  idx的10条肯定存在 因为 这个数据是加实际条数加起来的

所以 idx =1 就是取 2010-2000 =10条？ asc limit 10
那最小的表呢？ 最小的 就是取5条   用个desc limit 5
这样取会不会存在什么问题？
如果 表idx 0 被删除的剩下 总共 2条
idx 二 只删除了1条


那 取 idx 0  desc limit 5 就是有问题的
而是取 表二  应该是  实际的表数据 的范围
### 情况 最大最小都集中在一个表中 1
表扩展  表行数  表实际行数符合条件的
idx 0  0-2000  2
idx 1  2000-4000    1500
idx 2   2000-6000   1900
那取得时候实际 offset 1950 15
就是全部在表二  2+1500+1900 > 1995  大于最下数
 2+1500+1900 > 2010  大于最大数

这种情况直接 idx 2  where xx  limit desc 15 就好了

这里看和 idx 索引范围没有关系！！！

### 情况2  最大最小分在不同的表中  极端情况
还是取 offset 1995 limit 15
 表扩展   符合条件的行数
idx 0    1995
idx 1     3
idx 2     2
idx 3     50

实际操作检查
idx 0 1995  = 1995 没有
idx 1  3
             1995+3 = 1998   >1995  符合条件  3 = 1998-1995
                       2010- 1998 = 12
                        差12条       12 =  15 - 3

              sql:  desc pk limit 3
idx 2 1      1998+ 1 =1999 > 1998
             1999 < 2010  继续
             sql: desc pk limit 1

idx 3 10     1999 + 10 = 2009  > 1999
             2009 < 2010
              sql: desc pk limit 10
idx 4 20     2009 + 20 = 2029
             2029 > 2010  (到此结束)
             取得条数 2010 - 2009 = 1
             sql： desc pk limit 1

  完成
  最后 反序合并 从4 开始合并3 合并2

### 情况三   最大最小分在不同的表中  常规情况

当分类60个库 每个库10个表 就是600个表 这样做就会有性能问题！

那怎么处理呢？ 映射吗 直接存储每个表的 每个库的 有 多少行以及 每个表有多少行 然后通过区间算法 找到对应的
数据， 上边区间算法就可以！  把统计数据cache起来
per table  500000
表扩展   表行数  表实际行数符合条件的


idx 0   0-500000         490000
idx 1   500000-1000000   410000
idx 2   1000000 -1500000 480000

1. 取 offset 420000 15
 min 420000 max 420015

 420000 /500000 = 0
 420015 /500000 = 0

count  490000
if( count > min && count > max )
if( 490000 > 420000 &&  420015 < 490000 )
 from ext_0 limit 410000 15

2. 取 offset 489992 15
min 489995 max 490007

min  489995 /500000 = 0
max  490007 /500000 = 0

count  490000
    count > min && count < max
if( 490000 > 489995 && 490000 < 490007 )
    limit 490000-489995 5

idx + 1   idx =1
 15-5 =10
 if( count > min && count > max  )
 if( 410000 > 489992 && 410000 > 490007 )
**单独的行数和 偏移最大最小比较是有问题的**


3. offset  1000023 15

1000023/ 500000 = 2

count 410000 ？？？ 怎么搞！ 只有上边的算法是准去的 这种有删除的就不准了
起始 1000000  结尾是 1500000
1000023 > 1000000  1000023+15 < 1500000  在这个区域
count > limit   就可以吗？


4. 正常情况下 最多 两个表就解决问题 不会出现三个表的情况 即时删除
    1. 问题在于当删除太多 越往后的表偏差越大 就不能准确定位问题
    要准确就必须 每个表每个表的计算 像上边那样


4. 目录表(下边用动态cache代替目录表)
5. 解决方案 基于cache的 思路  100个表查询100次 进行cache 1800（ 半小时 ）
对结果进行逆排序 然后根据offset 构造sql语句



3.
























































































